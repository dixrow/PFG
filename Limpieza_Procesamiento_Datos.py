# -*- coding: utf-8 -*-
"""Limpieza y procesamiento de datos.

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HlYFEHzecYiaUuMfSJlSowAgId-wid17
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df=pd.read_csv('Creditos Bancarios.csv')

df



df.info()

# Número de registros nulos por columna
df.isna().sum()

# La dimensión del dataframe
df.shape

#Imponemos un umbral del 5%
umbral=len(df)*0.05

# Iterar sobre cada columna y eliminar los registros nulos si el número de valores nulos es menor que el umbral
for columna in df.columns:
    # Contar los valores nulos en la columna actual
    nulos_en_columna = df[columna].isnull().sum()

    # Verificar si el número de valores nulos está por debajo del umbral
    if nulos_en_columna < umbral:
        # Eliminar los registros nulos en la columna actual
        df = df.dropna(subset=[columna])

#Volver a mostrar el número de registros nulos en cada columna
df.isna().sum()

#Mostramos la dimensión del nuevo dataframe
df.shape

# Seleccionar solo las variables categóricas
variables_categoricas = df.select_dtypes(include=['object'])

# Inicializar un diccionario para almacenar la suma de registros de cada valor único
suma_registros_por_columna = {}

# Iterar sobre cada columna categórica
for columna in variables_categoricas.columns:
    # Obtener la serie de valores y contar su frecuencia
    valores_y_frecuencias = df[columna].value_counts()

    # Agregar la serie de valores y frecuencias al diccionario
    suma_registros_por_columna[columna] = valores_y_frecuencias

# Mostrar el resultado
for columna, valores_frecuencias in suma_registros_por_columna.items():
    print(f"Columna: {columna}")
    print(valores_frecuencias)
    print()

cat=[] #variables categóricas
num=[] #variables numéricas
for i in df.columns:
  if df[i].dtype=='object':
    cat.append(i)
  else:
    num.append(i)

print('cat = ',cat)
print('num = ',num)

for column in df[num]:
        plt.figure(figsize=(17,1))
        sns.boxplot(data=df[num], x=column)

# Sustituir los valores nulos en cada columna según el método indicado
df['LTV'].fillna(df['LTV'].median(), inplace=True)
df['rate_of_interest'].fillna(df['rate_of_interest'].mean(), inplace=True)
df['Interest_rate_spread'].fillna(df['Interest_rate_spread'].median(), inplace=True)
df['Upfront_charges'].fillna(df['Upfront_charges'].median(), inplace=True)
df['property_value'].fillna(df['property_value'].median(), inplace=True)
df['LTV'].fillna(df['LTV'].median(), inplace=True)
df['income'].fillna(df['income'].mode()[0], inplace=True)
df['dtir1'].fillna(df['dtir1'].mean(), inplace=True)
df.isna().sum()

cat=[] #variables categóricas sin nulos
num=[] #variables numéricas sin nulos
for i in df.columns:
  if df[i].dtype=='object':
    cat.append(i)
  else:
    num.append(i)
num.remove('year')
num.remove('ID')
num.remove('term')
num.remove('Status')
num.remove('LTV')

# Definición de la función eliminar_outlier
def eliminar_outlier(col):
    Q1, Q3 = col.quantile(0.25), col.quantile(0.75)
    IQR = Q3 - Q1
    lowerthr = Q1 - (1.5 * IQR)  # UMBRAL INFERIOR
    upperthr = Q3 + (1.5 * IQR)  # UMBRAL SUPERIOR
    return col[(col >= lowerthr) & (col <= upperthr)]

# Eliminar los outliers en cada columna numérica
for column in df[num]:
    df[column] = eliminar_outlier(df[column])
# Graficar el diagrama de caja para cada columna después de eliminar los outliers
for column in df[num]:
    plt.figure(figsize=(17, 1))
    sns.boxplot(data=df, x=column)
    plt.show()